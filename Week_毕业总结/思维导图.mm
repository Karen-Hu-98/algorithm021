
<map>
  <node ID="root" TEXT="ppt - outline">
    <node TEXT="数据结构 " ID="HfmBQo0UKN" STYLE="bubble" POSITION="default">
      <node TEXT="一维" ID="ipmstDWrkW" STYLE="fork">
        <node TEXT="基础" ID="jG8ukRyr6p" STYLE="fork">
          <node TEXT="数组 Array" ID="27dhDuIgcd" STYLE="fork">
            <node TEXT="时间复杂度" ID="aVUbZR5mce" STYLE="fork">
              <node TEXT="查找 O(N)" ID="6Gb3X1OKoY" STYLE="fork"/>
              <node TEXT="插入 O(N)" ID="4pO6fU8SXx" STYLE="fork"/>
              <node TEXT="删除 O(N)" ID="H55jgCJol3" STYLE="fork"/>
            </node>
            <node TEXT="Array" ID="KUIGhM6hr1" STYLE="fork">
              <node TEXT="Array - 增加元素" ID="Q8k14k0Ske" STYLE="fork"/>
              <node TEXT="Array - 删除元素" ID="lU7JdswlOx" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="字符串 String" ID="LH59Gjwcds" STYLE="fork">
            <node TEXT="String" ID="mTbrECTMCN" STYLE="fork"/>
            <node TEXT="遍历字符串" ID="0dhX03c2MF" STYLE="fork"/>
            <node TEXT="字符串比较" ID="aUEFX4N2Rx" STYLE="fork"/>
            <node TEXT="例题" ID="dSLUrLhUOa" STYLE="fork">
              <node TEXT="Atoi" ID="DKfYCuPNO9" STYLE="fork"/>
              <node TEXT="字符串操作问题" ID="pvhyQXrtCM" STYLE="fork"/>
              <node TEXT="Anagram异位词问题" ID="M1nTITFDcf" STYLE="fork"/>
              <node TEXT="Palindrome回文串问题" ID="5KInuPDDnq" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="链表 Linked List" ID="slaxK2DAm0" STYLE="fork">
            <node TEXT="时间复杂度" ID="8fdGpkLBAX" STYLE="fork">
              <node TEXT="查找 O(N)" ID="YgmSsBhbO8" STYLE="fork"/>
              <node TEXT="插入 O(1)" ID="DjLDB5VRii" STYLE="fork"/>
              <node TEXT="删除 O(1)" ID="AOKUDQ1pGa" STYLE="fork"/>
            </node>
            <node TEXT="Linked List" ID="TZAHGaLwDt" STYLE="fork">
              <node TEXT="Linked List - 增加结点" ID="jbBsfX1H8w" STYLE="fork"/>
              <node TEXT="Linked List - 删除结点" ID="ij6wYYFDeT" STYLE="fork"/>
            </node>
            <node TEXT="Double Linked List" ID="W8IHFJEOkT" STYLE="fork"/>
          </node>
          <node TEXT="跳表 Skip List" ID="vg8VYxo51N" STYLE="fork">
            <node TEXT="时间复杂度" ID="MubsecjF0J" STYLE="fork">
              <node TEXT="查找 O(log N)" ID="xDeuPFOV5u" STYLE="fork"/>
              <node TEXT="插入 O(log N)" ID="6pwHcJTEIG" STYLE="fork"/>
              <node TEXT="删除 O(log N)" ID="6RXUD0aGNx" STYLE="fork"/>
              <node TEXT="时间复杂度分析" ID="lGM9WdYBnl" STYLE="fork"/>
            </node>
            <node TEXT="空间复杂度" ID="BBGMT2DFQx" STYLE="fork">
              <node TEXT="O(n)" ID="6pWByb2TYt" STYLE="fork"/>
            </node>
            <node TEXT="特点" ID="3YFXtt8y6Y" STYLE="fork">
              <node TEXT="只能用于元素有序的情况" ID="LTbIDS5aXP" STYLE="fork"/>
              <node TEXT="跳表对标的是平衡树（AVL Tree）和二分查找，是一种 插入/删除/搜索 都是O(log N)的数据结构" ID="eWdBW2bpld" STYLE="fork"/>
              <node TEXT="1989年出现" ID="gUDz9msLd7" STYLE="fork"/>
              <node TEXT="最大的优势：原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目里用来替代平衡树，如Redis、LevelDB等" ID="L2gYLeHhur" STYLE="fork"/>
              <node TEXT="现实中跳表的形态" ID="pQhrBz7Xv9" STYLE="fork"/>
            </node>
            <node TEXT="工程中的应用" ID="OcL8l6HP7y" STYLE="fork">
              <node TEXT="LRU Cache - Linked List" ID="WF1YU3yqoH" STYLE="fork"/>
              <node TEXT="Redis - Linked List" ID="eLuEkLzYBm" STYLE="fork"/>
            </node>
            <node TEXT="如何给有序的链表加速" ID="WWHagwRXJw" STYLE="fork">
              <node TEXT="添加第一级索引" ID="Oec81tS4Yq" STYLE="fork"/>
              <node TEXT="添加第二级索引" ID="x8tl5Z3m7Z" STYLE="fork"/>
              <node TEXT="以此类推，增加多级索引" ID="Yhdi0rFHjs" STYLE="fork"/>
            </node>
          </node>
        </node>
        <node TEXT="高级" ID="e4usTGoJvo" STYLE="fork">
          <node TEXT="栈 Stack" ID="febwkRZyhe" STYLE="fork">
            <node TEXT="时间复杂度" ID="zCgFUkqomf" STYLE="fork">
              <node TEXT="查找 O(N)" ID="ObW9c5R1gK" STYLE="fork"/>
              <node TEXT="插入 O(1)" ID="zjZN2ixGqy" STYLE="fork"/>
              <node TEXT="删除 O(1)" ID="uxg5D5Eiu1" STYLE="fork"/>
            </node>
            <node TEXT="Stack" ID="j7IaBQdS6F" STYLE="fork"/>
            <node TEXT="特点：先入后出" ID="noXEq1RkrL" STYLE="fork"/>
            <node TEXT="示例代码" ID="2AtD0W4xH3" STYLE="fork"/>
            <node TEXT="Java的Stack源码" ID="vQooFDbDaT" STYLE="fork">
              <node TEXT="http://developer.classpath.org/doc/java/util/Stack-source.html" ID="oUJNuYfiix" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="队列 Queue" ID="eX1USzFGZp" STYLE="fork">
            <node TEXT="时间复杂度" ID="gREWulQWlg" STYLE="fork">
              <node TEXT="查找 O(N)" ID="lXQJNzNL78" STYLE="fork"/>
              <node TEXT="插入 O(1)" ID="O6iRT7PhPh" STYLE="fork"/>
              <node TEXT="删除 O(1)" ID="eF0BD9iXcq" STYLE="fork"/>
            </node>
            <node TEXT="Queue" ID="6SnXvKrlzz" STYLE="fork"/>
            <node TEXT="特点：先入先出" ID="KQzgrqvIO4" STYLE="fork"/>
            <node TEXT="示例代码" ID="hH1kTPA2Nh" STYLE="fork"/>
            <node TEXT="Java的Queue源码" ID="HVGDD8ugvk" STYLE="fork">
              <node TEXT="http://fuseyism.com/classpath/doc/java/util/Queue-source.html" ID="s6BW1ykDbj" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="双端队列 Deque" ID="twvyQ0hSXY" STYLE="fork">
            <node TEXT="时间复杂度" ID="qPMqYcuige" STYLE="fork">
              <node TEXT="查找 O(N)" ID="BmI52xmisC" STYLE="fork"/>
              <node TEXT="插入 O(1)" ID="TG63VKMA5K" STYLE="fork"/>
              <node TEXT="删除 O(1)" ID="j5nkMqBY8X" STYLE="fork"/>
            </node>
            <node TEXT="Deque：Double-End Queue" ID="V0IxmkHrAJ" STYLE="fork"/>
            <node TEXT="特点：两端都可以进出的Queue" ID="sdvoCBPszV" STYLE="fork"/>
            <node TEXT="示例代码" ID="GQ80f7B02X" STYLE="fork"/>
          </node>
          <node TEXT="优先队列 Priority Queue" ID="xTYifIJb6j" STYLE="fork">
            <node TEXT="时间复杂度" ID="3o95tlmSx9" STYLE="fork">
              <node TEXT="插入 O(1)" ID="tdRRV7BdOH" STYLE="fork"/>
              <node TEXT="取出 O(log N) - 按照元素的优先级取出" ID="k7DJ6svtyN" STYLE="fork"/>
            </node>
            <node TEXT="底层的具体实现的数据结构较为多样和复杂：Heap、BST、Treap" ID="rDv1Vher0x" STYLE="fork"/>
            <node TEXT="Java的Priority Queue" ID="GeHkoqEbT5" STYLE="fork">
              <node TEXT="https://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html" ID="z1u7sX4aYs" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="哈希表 Hash Table" ID="KQo74PzbRd" STYLE="fork">
            <node TEXT="时间复杂度" ID="LKCdn5YLNH" STYLE="fork">
              <node TEXT="查找 O(1)" ID="u9hRHtnKhL" STYLE="fork"/>
              <node TEXT="插入 O(1)" ID="SiojJwkY89" STYLE="fork"/>
              <node TEXT="删除 O(1)" ID="bLMyscNsnN" STYLE="fork"/>
            </node>
            <node TEXT="定义" ID="b5A79PlGkH" STYLE="fork">
              <node TEXT="哈希表，也叫散列表，是根据关键码值（Key Value)而直接进行访问的数据结构" ID="ZRzoQvmPOq" STYLE="fork"/>
              <node TEXT="它通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度" ID="jaGoqJOY6e" STYLE="fork"/>
              <node TEXT="这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表（或散列表）" ID="c4keG1Q3qm" STYLE="fork"/>
            </node>
            <node TEXT="工程实践" ID="jgTihu5Yxa" STYLE="fork">
              <node TEXT="电话号码簿" ID="XiPGuWD8m5" STYLE="fork"/>
              <node TEXT="用户信息表" ID="ZSTIMXOY6r" STYLE="fork"/>
              <node TEXT="缓存（LRU Cache）" ID="q4vJPd2dRl" STYLE="fork"/>
              <node TEXT="键值对存储（Redis）" ID="Yzs8Rqv3Bl" STYLE="fork"/>
            </node>
            <node TEXT="Hash Function" ID="LAiEBbGV3N" STYLE="fork"/>
            <node TEXT="Hash Collisions" ID="RfbM8KQ4de" STYLE="fork"/>
          </node>
          <node TEXT="映射 Map" ID="NsSne5RxVK" STYLE="fork">
            <node TEXT="Java Code " ID="lMOCZ0X5ir" STYLE="fork"/>
            <node TEXT="Java Map classes" ID="4Jbc9Fbrxj" STYLE="fork">
              <node TEXT="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html" ID="YxsqRWvtpC" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="集合 Set" ID="M1Jn9Mn6on" STYLE="fork">
            <node TEXT="Java Code" ID="OO1ia73IXX" STYLE="fork"/>
            <node TEXT="Java Set classes" ID="QoIWCHUZRg" STYLE="fork">
              <node TEXT="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html" ID="qRJCm7R1yZ" STYLE="fork"/>
            </node>
          </node>
        </node>
      </node>
      <node TEXT="二维" ID="O6m81tba05" STYLE="fork">
        <node TEXT="基础" ID="KLD4OHjuJm" STYLE="fork">
          <node TEXT="树 Tree" ID="HZciKKYqII" STYLE="fork">
            <node TEXT="树 Tree" ID="mAENRFMXbm" STYLE="fork"/>
            <node TEXT="Linked List 是特殊化的Tree" ID="lAnIUl1M2t" STYLE="fork"/>
            <node TEXT="示例代码" ID="Bk0UU8iduj" STYLE="fork"/>
          </node>
          <node TEXT="二叉树 Binary Tree" ID="3jvZulEzwU" STYLE="fork">
            <node TEXT="二叉树 Binary Tree" ID="O5UnjDWNtZ" STYLE="fork"/>
            <node TEXT="二叉树遍历" ID="gMyTMNcAks" STYLE="fork">
              <node TEXT="前序(Pre-order)：根-左-右" ID="Ondxr5JtPh" STYLE="fork"/>
              <node TEXT="中序(In-order)：左-根-右" ID="0Swlr5giVM" STYLE="fork"/>
              <node TEXT="后序(Post-order)：左-右-根" ID="1i15ibjPn9" STYLE="fork"/>
            </node>
            <node TEXT="示例代码（python）" ID="o8vhOwdfCJ" STYLE="fork"/>
          </node>
          <node TEXT="二叉搜索树 Binary Search Tree" ID="uPMlmN9cVT" STYLE="fork">
            <node TEXT="二叉搜索树 Binary Search Tree" ID="KLoxlBN4ey" STYLE="fork"/>
            <node TEXT="二叉树遍历" ID="yuVgh4ZgTa" STYLE="fork">
              <node TEXT="前序(Pre-order)：根-左-右" ID="TVTYxtLWPu" STYLE="fork"/>
              <node TEXT="中序(In-order)：左-根-右  （升序排列）" ID="kHdIQuqI5J" STYLE="fork"/>
              <node TEXT="后序(Post-order)：左-右-根" ID="HTX1dG0a74" STYLE="fork"/>
            </node>
            <node TEXT="定义" ID="DXFkrcbDrY" STYLE="fork">
              <node TEXT="二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树" ID="uSBd4ANFxJ" STYLE="fork">
                <node TEXT="左子树上所有结点的值均小于他的根结点的值" ID="pSZiOQLq18" STYLE="fork"/>
                <node TEXT="右子树上所有结点的值均大于它的根节点的值" ID="XnMJtmgpbF" STYLE="fork"/>
                <node TEXT="以此类推：左、右子树也分别为二叉查找树（重复性！）" ID="L0IvsnMhKa" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="二叉搜索树常见操作" ID="BKBQUsBXxE" STYLE="fork">
              <node TEXT="查询" ID="kp0K9HZk5G" STYLE="fork"/>
              <node TEXT="插入新结点（创建）" ID="PryGBGud9A" STYLE="fork"/>
              <node TEXT="删除" ID="QjPDcTn3TL" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="图 Graph" ID="Rtngj6uc93" STYLE="fork">
            <node TEXT="图 Graph" ID="S3FWZrQecA" STYLE="fork"/>
            <node TEXT="属性" ID="HC37vKqAOh" STYLE="fork">
              <node TEXT="Graph(V, E)" ID="YV6ayzpm46" STYLE="fork">
                <node TEXT="V - Vertex：点" ID="dO8Frr3bn0" STYLE="fork">
                  <node TEXT="1. 度 - 入度 &amp; 出度" ID="mIDeQQKqn7" STYLE="fork"/>
                  <node TEXT="2.点与点之间：连通与否" ID="XNFgJg1SPE" STYLE="fork"/>
                </node>
                <node TEXT="E - Edge：边" ID="Z6mgOLg3Ws" STYLE="fork">
                  <node TEXT="1.有向 &amp; 无向 （单行线）" ID="W17UHbStMX" STYLE="fork"/>
                  <node TEXT="2.权重（边长）" ID="iSy84n755g" STYLE="fork"/>
                </node>
              </node>
            </node>
            <node TEXT="图表示和分类" ID="qL6DqZuUzt" STYLE="fork">
              <node TEXT="无向无权图" ID="mFe5qBt0bB" STYLE="fork"/>
              <node TEXT="有向无权图" ID="x6dwmDa5Lh" STYLE="fork"/>
              <node TEXT="无向有权图" ID="GHckjRJ9jr" STYLE="fork"/>
            </node>
            <node TEXT="基于图的常见算法" ID="ZrfGjiXXQO" STYLE="fork">
              <node TEXT="DFS代码 - 递归写法" ID="P6CGKZysGD" STYLE="fork"/>
              <node TEXT="BFS代码" ID="4GHvtrzEtA" STYLE="fork"/>
              <node TEXT="图的高级算法" ID="9BaynX2imn" STYLE="fork">
                <node TEXT="连接图个数" ID="KJZ8yEhkZf" STYLE="fork"/>
                <node TEXT="拓扑排序（Topological Sorting）" ID="MC3RvAxKcD" STYLE="fork"/>
                <node TEXT="最短路径（Shortest Path）" ID="OgHOnvxGAe" STYLE="fork"/>
                <node TEXT="最小生成树（Minimum Spanning Tree）" ID="HzpQSaLdly" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="Tree 是特殊化的Graph" ID="0dyDruXMhv" STYLE="fork"/>
          </node>
        </node>
        <node TEXT="高级" ID="Sy9EE2cxE3" STYLE="fork">
          <node TEXT="二叉搜索树 Binary Search Tree" ID="PmG9R0FoIu" STYLE="fork">
            <node TEXT="时间复杂度" ID="X2JD4nJQUR" STYLE="fork">
              <node TEXT="查找 O(log N)" ID="dPRFFoBS59" STYLE="fork"/>
              <node TEXT="插入 O(log N)" ID="uxL1UiRRiY" STYLE="fork"/>
              <node TEXT="删除 O(log N)" ID="NObhcLhh2c" STYLE="fork"/>
            </node>
            <node TEXT="红黑树Red-Black Tree" ID="NVL9ENUbZ6" STYLE="fork">
              <node TEXT="定义" ID="N3JyFdMQxZ" STYLE="fork">
                <node TEXT="红黑树是一种近似平衡的二叉搜索树，它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树" ID="8cArvTCNKd" STYLE="fork">
                  <node TEXT="每个结点要么是红色，要么是黑色" ID="WST4A03i5t" STYLE="fork"/>
                  <node TEXT="根结点是黑色" ID="Q1PlXZ5Bhi" STYLE="fork"/>
                  <node TEXT="每个叶结点（NIL结点、空结点）是黑色的" ID="pC5L7JD8uG" STYLE="fork"/>
                  <node TEXT="不能有相邻接的两个红色结点" ID="an4IjQRsbE" STYLE="fork"/>
                  <node TEXT="从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点" ID="VZP9H9oswT" STYLE="fork"/>
                </node>
              </node>
              <node TEXT="关键性质" ID="utkg33rhMr" STYLE="fork">
                <node TEXT="从根岛叶子的最长的可能路径不多于最短的可能路径的两倍长" ID="HcaDFZSdah" STYLE="fork"/>
              </node>
              <node TEXT="Red-Black Tree （1）" ID="locdvDlCvX" STYLE="fork"/>
              <node TEXT="Red-Black Tree（2）" ID="P3kLyVUtLI" STYLE="fork"/>
            </node>
            <node TEXT="AVL树" ID="MZBdcRTvro" STYLE="fork">
              <node TEXT="定义" ID="3yg15qypO2" STYLE="fork">
                <node TEXT="Balance Factor 平衡因子" ID="rvEQTesDtq" STYLE="fork"/>
                <node TEXT="是它的左子树的高度减去它右子树的高度（有时相反）" ID="eZUTPr20MZ" STYLE="fork"/>
                <node TEXT="Balance Factor = {-1，0，1}" ID="4hUQoGZgvy" STYLE="fork"/>
                <node TEXT="通过旋转操作来进行平衡" ID="1kdTyfXgAd" STYLE="fork"/>
              </node>
              <node TEXT="不足：" ID="gLvXs8q6Td" STYLE="fork">
                <node TEXT="结点需要存储额外信息、且调整次数频繁" ID="FqZzB1nlkY" STYLE="fork"/>
              </node>
              <node TEXT="记录左右子树高度" ID="QgZlRaazeX" STYLE="fork"/>
              <node TEXT="旋转操作" ID="7mmZCW0DHy" STYLE="fork">
                <node TEXT="1. 左旋" ID="JFlWwnvO7Z" STYLE="fork"/>
                <node TEXT="2. 右旋" ID="a54tvAaJLp" STYLE="fork"/>
                <node TEXT="3. 左右旋" ID="CeZyNij8ow" STYLE="fork"/>
                <node TEXT="4. 右左旋" ID="dm8H5nPoJ1" STYLE="fork"/>
              </node>
            </node>
          </node>
          <node TEXT="堆 Heap" ID="m0uaSzmQ4U" STYLE="fork">
            <node TEXT="定义" ID="pdJdMsCYnX" STYLE="fork">
              <node TEXT="可以迅速找到一堆数中的最大或者最小值的数据结构" ID="9c8sSM4hl7" STYLE="fork"/>
              <node TEXT="将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆" ID="aGAggJWngJ" STYLE="fork"/>
              <node TEXT="常见的堆" ID="HJh3OhIwtz" STYLE="fork">
                <node TEXT="二叉堆" ID="ebhP7xIaY9" STYLE="fork"/>
                <node TEXT="斐波那契堆" ID="daW6VHUl5p" STYLE="fork"/>
              </node>
              <node TEXT="假设是大顶堆，则常见操作（API)" ID="ZMPrtDaOlq" STYLE="fork">
                <node TEXT="find-max: O(1)" ID="7XkT5m2P6a" STYLE="fork"/>
                <node TEXT="delete-max: O(log N)" ID="9tSabNiV8F" STYLE="fork"/>
                <node TEXT="inset(create):O(log N) or O(1)" ID="UjAZKDgDz0" STYLE="fork"/>
              </node>
            </node>
          </node>
          <node TEXT="二叉堆 Binary Heap" ID="mzmBjTy247" STYLE="fork">
            <node TEXT="二叉堆 Binary Heap" ID="MhySwlyOvZ" STYLE="fork">
              <node TEXT="0. 根节点（顶堆元素）是：a[0]" ID="nfRpoDG7e2" STYLE="fork"/>
              <node TEXT="1. 索引为i的左孩子的索引是（2*i+1）" ID="TB9KsrgzvQ" STYLE="fork"/>
              <node TEXT="2. 索引为i的右孩子的索引是（2*i+2）" ID="Q5ODYUaMtV" STYLE="fork"/>
              <node TEXT="3.索引为i的父结点的索引是 floor((i-1)/2) " ID="ie95iQ82SA" STYLE="fork"/>
            </node>
            <node TEXT="性质" ID="rTlVb9jFjO" STYLE="fork">
              <node TEXT="通过完全二叉树来实现(不是二叉搜索树）" ID="aQCu1uBqvh" STYLE="fork"/>
              <node TEXT="二叉堆（大顶）满足下列性质：" ID="EV3Gv3mhzZ" STYLE="fork">
                <node TEXT="【性质一】是一棵完全树" ID="FmvlvAI5q6" STYLE="fork"/>
                <node TEXT="【性质二】树中任意节点的值总是&gt;=其子节点的值" ID="6rXLw2twFq" STYLE="fork"/>
              </node>
              <node TEXT="二叉堆是堆（优先队列 Priority Queue）的一种常见且简单的实现；但是并不是最优的实现" ID="5tPK5nA6cc" STYLE="fork"/>
            </node>
            <node TEXT="实现细节" ID="3eFaYijiCD" STYLE="fork">
              <node TEXT="1. 二叉堆一般都通过“数组”来实现" ID="2xs489ix0d" STYLE="fork"/>
              <node TEXT="2. 假设“第一个元素”在数组中的索引为0的话，则父节点和子节点的位置关系如下" ID="HNled4M5Rj" STYLE="fork">
                <node TEXT="（01）索引为i的左孩子的索引是（2*i+1）" ID="egQPEgSSeY" STYLE="fork"/>
                <node TEXT="（02）索引为i的右孩子的索引是（2*i+2)" ID="U8VGc0AYGs" STYLE="fork"/>
                <node TEXT="（03）索引为i的父孩子的索引是floor((i-1)/2)" ID="XmTHI3izuz" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="Insert 插入操作" ID="5oIpAIkqkf" STYLE="fork">
              <node TEXT="1. 新元素一律先插入到堆的尾部" ID="TySqE9vz4X" STYLE="fork"/>
              <node TEXT="2. 依次向上调整整个堆的结构（一直到根即可）" ID="rgebWkWWbb" STYLE="fork"/>
              <node TEXT="HeapifyUp" ID="TTMK5kluZL" STYLE="fork"/>
              <node TEXT="时间复杂度：O(log N)" ID="EubUVI9saI" STYLE="fork"/>
              <node TEXT="操作" ID="eHH8DfjPTQ" STYLE="fork"/>
            </node>
            <node TEXT="Delete Max删除堆顶操作" ID="YdHzX3LSNW" STYLE="fork">
              <node TEXT="1.将堆尾元素替换到顶部（即，对顶被替代删除掉）" ID="6hWYEsW1t4" STYLE="fork"/>
              <node TEXT="2.依次从根部向下调整整个堆的结构（一直到堆尾即可）" ID="1AAEkEHXQB" STYLE="fork"/>
              <node TEXT="HeapifyDown" ID="lhgeLRk6hX" STYLE="fork"/>
              <node TEXT="" ID="xCXJ184fyg" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="并查集 Disjoint Set" ID="8HZrFvZmWQ" STYLE="fork">
            <node TEXT="适用场景" ID="DSndnJLUZ7" STYLE="fork">
              <node TEXT="组团、配对问题" ID="BUxvkwQcsW" STYLE="fork"/>
              <node TEXT="Group or not？" ID="01H9JuA42x" STYLE="fork"/>
            </node>
            <node TEXT="基本操作" ID="23xcwYb5MO" STYLE="fork">
              <node TEXT="makeSet(s)：建立一个新的并查集，其中包含s个单元素集合" ID="TgG3Bk6w6I" STYLE="fork"/>
              <node TEXT="unionSet(x, y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并" ID="wZCqjobvkV" STYLE="fork"/>
              <node TEXT="find(x)：找到元素x所在的集合的代表，该操作也可以用于判断用于两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了" ID="TOHHgp2OoP" STYLE="fork"/>
            </node>
            <node TEXT="初始化" ID="f30WYWTgsV" STYLE="fork"/>
            <node TEXT="查询、合并" ID="Vup4wqr3AZ" STYLE="fork"/>
            <node TEXT="路径压缩" ID="DIrjqJ1F9o" STYLE="fork"/>
            <node TEXT="Java实现" ID="GdEcKsuMJW" STYLE="fork"/>
          </node>
          <node TEXT="字典树 Trie" ID="S8HuTgo9bG" STYLE="fork">
            <node TEXT="基本结构" ID="4wozuaR0rj" STYLE="fork">
              <node TEXT="字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计" ID="FF2aViEubF" STYLE="fork"/>
            </node>
            <node TEXT="优点" ID="JXf2yNUcNE" STYLE="fork">
              <node TEXT="最大限度地减少无谓的字符串比较，查询效率比哈希表高" ID="udGWaulXEs" STYLE="fork"/>
            </node>
            <node TEXT="基本性质" ID="xaUXinECpZ" STYLE="fork">
              <node TEXT="1. 结点本身不存完整单词" ID="565J59XLHK" STYLE="fork"/>
              <node TEXT="2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串" ID="lol7ytTorh" STYLE="fork"/>
              <node TEXT="3. 每个结点的所有子结点路径代表的字符都不相同" ID="q09GstLDuS" STYLE="fork"/>
            </node>
            <node TEXT="核心思想" ID="dcxrK3rhg0" STYLE="fork">
              <node TEXT="Trie树的核心思想是空间换时间" ID="7i44CxOBF8" STYLE="fork"/>
              <node TEXT="利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的" ID="ZrB7HuUNYB" STYLE="fork"/>
            </node>
            <node TEXT="结点存储额外信息" ID="zIi6NZaU07" STYLE="fork"/>
            <node TEXT="结点的内部实现" ID="hISX62Csze" STYLE="fork"/>
            <node TEXT="Trie树代码模板" ID="5nrBHuLO9s" STYLE="fork"/>
          </node>
        </node>
      </node>
      <node TEXT="特殊" ID="UdURuIIY0c" STYLE="fork">
        <node TEXT="位运算 Bitwise" ID="gZTgTpD6yo" STYLE="fork">
          <node TEXT="为什么需要位运算" ID="kMBKlv0NuO" STYLE="fork">
            <node TEXT="机器里的数字表示方式和存储格式就是 二进制" ID="ebFRaacn50" STYLE="fork"/>
            <node TEXT="十进制&lt;-&gt;二进制 （如何转换）" ID="E8cIVKarvM" STYLE="fork"/>
          </node>
          <node TEXT="位运算符" ID="nNgxaavgwM" STYLE="fork"/>
          <node TEXT="指定位置的位运算" ID="DkpciKC01E" STYLE="fork"/>
          <node TEXT="实战位运算要点" ID="haA4pjtpP0" STYLE="fork"/>
          <node TEXT="Java示例代码" ID="KgyDwu4VrY" STYLE="fork"/>
        </node>
        <node TEXT="布隆过滤器 BloomFilter" ID="eOqvPhnuFJ" STYLE="fork">
          <node TEXT="定义" ID="271WFyJjr8" STYLE="fork">
            <node TEXT="一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否存在在一个集合中" ID="qrdKeKiEGd" STYLE="fork"/>
            <node TEXT="优点" ID="nGWDqCinNg" STYLE="fork">
              <node TEXT="空间效率和查询效率都远远超过一半的算法" ID="JIhELrISUj" STYLE="fork"/>
            </node>
            <node TEXT="缺点" ID="i2ehsZTLyr" STYLE="fork">
              <node TEXT="有一定的误识别率和删除困难" ID="WCHlo7Qyvf" STYLE="fork"/>
            </node>
          </node>
          <node TEXT="BloomFilter = HashTable + 拉链存储重复元素" ID="7AEx6OBxTO" STYLE="fork"/>
          <node TEXT="示意图" ID="yWAqUKVNIo" STYLE="fork"/>
          <node TEXT="案例" ID="HVjFu2ycsn" STYLE="fork">
            <node TEXT="比特币网络" ID="B3C96Mdcfa" STYLE="fork"/>
            <node TEXT="分布式系统（Map-Reduce）-  Hadoop、Search Engine" ID="PMRM9wr8Zw" STYLE="fork"/>
            <node TEXT="Redis缓存" ID="t0euYwyxlV" STYLE="fork"/>
            <node TEXT="垃圾邮件、评论等的过滤" ID="qWhSnQWqVI" STYLE="fork"/>
          </node>
          <node TEXT="" ID="qoU89Y7f8x" STYLE="fork"/>
        </node>
        <node TEXT="LRU Cache" ID="m7TulRhtlP" STYLE="fork">
          <node TEXT="时间复杂度" ID="QyET6Nbizx" STYLE="fork">
            <node TEXT="查询  O(1)" ID="mHLBMmZ68s" STYLE="fork"/>
            <node TEXT="修改  O(1)" ID="RFtKtQGBiG" STYLE="fork"/>
            <node TEXT="更新  O(1)" ID="Cv0nsKlBQb" STYLE="fork"/>
          </node>
          <node TEXT="工作示例" ID="LlvbBBwOyF" STYLE="fork"/>
          <node TEXT="Java示例代码" ID="fQxF53mcwM" STYLE="fork"/>
        </node>
      </node>
    </node>
    <node TEXT="算法 " ID="H3PcgUv3Tr" STYLE="bubble" POSITION="default">
      <node TEXT="if-else, switch -&gt; branch" ID="DZgiM1tayd" STYLE="fork"/>
      <node TEXT="for, while loop -&gt; iteration" ID="63daEjPqLU" STYLE="fork"/>
      <node TEXT="递归 Recursion " ID="bOZxKtzb8z" STYLE="fork">
        <node TEXT="递归 Recursion" ID="3UZsT9LyiK" STYLE="fork">
          <node TEXT="本质" ID="szBOPEkqft" STYLE="fork">
            <node TEXT="递归 - 循环" ID="1G91L8sQOj" STYLE="fork"/>
            <node TEXT="通过函数体来进行的循环" ID="ENOIj79wyb" STYLE="fork"/>
            <node TEXT="寻找重复性-&gt;计算机指令集" ID="Iou7Sn1ZrC" STYLE="fork"/>
          </node>
          <node TEXT="Java代码模板" ID="oXX9FJNMD9" STYLE="fork"/>
          <node TEXT="思维要点" ID="fPw4POcj8l" STYLE="fork">
            <node TEXT="1. 不要人肉进行递归（最大误区）" ID="efCCZ0fmdL" STYLE="fork"/>
            <node TEXT="2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）" ID="Kzdhi89bOm" STYLE="fork"/>
            <node TEXT="3. 数学归纳法思维" ID="gi5bNGW8XW" STYLE="fork"/>
          </node>
        </node>
        <node TEXT="分治 Divide &amp; Conquer" ID="IGfdnGU9ph" STYLE="fork">
          <node TEXT="递归状态树" ID="AxcLxXoK9n" STYLE="fork"/>
          <node TEXT="Divide &amp; Conquer" ID="xkk69WUDlx" STYLE="fork"/>
          <node TEXT="分治代码模板" ID="HTwH5zVuOS" STYLE="fork"/>
        </node>
        <node TEXT="回溯 Backtracking" ID="RKyjtTWTer" STYLE="fork">
          <node TEXT="定义" ID="r3eUjpqZ4X" STYLE="fork">
            <node TEXT="回溯法采用试错的思想，它尝试分步的去解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分布解答再次尝试寻找问题的答案" ID="YHtWhAKFZd" STYLE="fork"/>
            <node TEXT="回溯法通常用最简单的递归方法来实现，再反复重复上述的步骤后可能出现两种情况" ID="rEOxdEyhGc" STYLE="fork">
              <node TEXT="找到一个可能存在的正确的答案" ID="PfwkNm8SVw" STYLE="fork"/>
              <node TEXT="在尝试了所有可能的分步方法后宣告该问题没有答案" ID="ZUmsIR3Ec4" STYLE="fork"/>
            </node>
            <node TEXT="在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算" ID="GbHE5024bk" STYLE="fork"/>
          </node>
        </node>
      </node>
      <node TEXT="搜索 Search" ID="a0vLXvB4UF" STYLE="fork">
        <node TEXT="搜索 Search - 遍历" ID="KZTcbhd7r3" STYLE="fork">
          <node TEXT="每个节点都要访问一次" ID="NEyIrB4Orp" STYLE="fork"/>
          <node TEXT="每个节点仅仅要访问一次" ID="yDaedQSTcp" STYLE="fork"/>
          <node TEXT="对于节点的访问顺序不限" ID="aRYnZ0m6vt" STYLE="fork">
            <node TEXT="深度优先搜索：Depth First Search" ID="Ktnh3xbo5q" STYLE="fork"/>
            <node TEXT="广度优先搜索：Breadth First Search" ID="a9Tb6LK43F" STYLE="fork"/>
          </node>
        </node>
        <node TEXT="深度优先搜索 Depth First Search （DFS)" ID="FVOMtM0zas" STYLE="fork">
          <node TEXT="遍历顺序" ID="5ERZl7FeBt" STYLE="fork"/>
          <node TEXT="DFS代码模板" ID="TkxymuJzjp" STYLE="fork"/>
        </node>
        <node TEXT="广度优先搜索 Breadth First Search （BFS)" ID="QKooMYutZb" STYLE="fork">
          <node TEXT="遍历顺序" ID="YfrJtg6wRm" STYLE="fork"/>
          <node TEXT="BFS代码模板" ID="y9U0bl4CGb" STYLE="fork"/>
        </node>
        <node TEXT="剪枝" ID="GWDgB3cPJq" STYLE="fork">
          <node TEXT="Example：三子棋" ID="WeLwPqPkd4" STYLE="fork"/>
        </node>
        <node TEXT="双向BFS" ID="IxXzWfxJmy" STYLE="fork">
          <node TEXT="BFS" ID="GJDBiiZmzK" STYLE="fork"/>
          <node TEXT="Breadth-First Search Levels" ID="TRn5KKIlpt" STYLE="fork"/>
          <node TEXT="Two-ended BFS 双向BFS" ID="pSwuq9OAfh" STYLE="fork"/>
        </node>
        <node TEXT="启发式搜索 Heuristic Search A*" ID="mNgUOrTZGN" STYLE="fork"/>
      </node>
      <node TEXT="动态规划 Dynamic Programming" ID="p7PBQHllkK" STYLE="fork">
        <node TEXT="定义" ID="21TU9eL5GE" STYLE="fork">
          <node TEXT="Simplifying a complicated problem by breaking it down into simpler sub-problems." ID="guYongXzG7" STYLE="fork"/>
          <node TEXT="Divide &amp; Conquer + Optimal substructure 分治+最优子结构" ID="4DIFq1FeDs" STYLE="fork"/>
        </node>
        <node TEXT="关键点" ID="3eKT4EceMr" STYLE="fork">
          <node TEXT="动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）" ID="tnsLWJciUX" STYLE="fork"/>
          <node TEXT="共性：找到重复子问题" ID="bl1wPbxnR6" STYLE="fork"/>
          <node TEXT="差异性：最优子结构、中途可以淘汰次优解" ID="R8UA50HlGl" STYLE="fork"/>
        </node>
      </node>
      <node TEXT="二分查找 Binary Search" ID="hHYEQAF1UB" STYLE="fork">
        <node TEXT="前提" ID="iZVttnQU00" STYLE="fork">
          <node TEXT="1. 目标函数单调性（单调递增或者递减）" ID="pydEy2Ov4W" STYLE="fork"/>
          <node TEXT="2. 存在上下界（bounded）" ID="bP2tz5WsRZ" STYLE="fork"/>
          <node TEXT="3. 能够通过索引访问（index accessible）" ID="G7ZeWtKtqn" STYLE="fork"/>
        </node>
        <node TEXT="代码模板" ID="2xTfWmkdie" STYLE="fork"/>
        <node TEXT="示例" ID="2fQHYyqadv" STYLE="fork">
          <node TEXT="在递增数组里 [10，14，19，26，27，31，33，35，42，44]，查找31" ID="2SgQK8x7Op" STYLE="fork"/>
        </node>
      </node>
      <node TEXT="贪心算法 Greedy" ID="zzldLb6yXl" STYLE="fork">
        <node TEXT="定义" ID="cvqqPHB7sv" STYLE="fork">
          <node TEXT="贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即 最有利）的选择，从而希望导致结果是全局最好或最优的算法" ID="VPCHlCExNP" STYLE="fork"/>
          <node TEXT="贪心算法与动态规划的不同在于它堆每个子问题的解决方法都做出选择，不能回退。动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能" ID="HfRDuMqdL0" STYLE="fork"/>
          <node TEXT="贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案" ID="S0pQ16xOO3" STYLE="fork"/>
          <node TEXT="一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。由于贪心算法的高效性以及其所求得的答案比较接近最优结果，贪心算法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题" ID="FNMk1VDQi0" STYLE="fork"/>
        </node>
        <node TEXT="适用场景" ID="0tXhYziUwY" STYLE="fork">
          <node TEXT="问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解，这种子问题最优解称为最优子结构" ID="J3aMBGuT4i" STYLE="fork"/>
          <node TEXT="贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能" ID="WHj5EjUd1T" STYLE="fork"/>
        </node>
        <node TEXT="实战题目" ID="kWasaSMvAV" STYLE="fork">
          <node TEXT="Coin Change" ID="xT1MiWY9xT" STYLE="fork">
            <node TEXT="https://leetcode-cn.com/problems/coin-change/" ID="KH370kXM34" STYLE="fork"/>
            <node TEXT="当硬币可选集合固定：Coins = [20, 10, 5, 1]" ID="yFK1W59e2r" STYLE="fork"/>
            <node TEXT="求最少可以几个硬币拼出总数，比如 total = 36" ID="bTiKcL4qvC" STYLE="fork"/>
          </node>
          <node TEXT="贪心算法的反例" ID="uHFFAu7AqV" STYLE="fork">
            <node TEXT="非整除关系的硬币，可选集合：Coins = [10, 9, 1]" ID="S5F7i0Y7Bg" STYLE="fork"/>
            <node TEXT="求拼出总数为18最少需要几个硬币？" ID="y7ASICv5ER" STYLE="fork"/>
          </node>
        </node>
      </node>
      <node TEXT="排序算法" ID="w6OeIIVS4I" STYLE="fork">
        <node TEXT="1. 比较类排序" ID="YxdXWYFuTU" STYLE="fork">
          <node TEXT="定义" ID="8iV5f5x9q9" STYLE="fork">
            <node TEXT="通过比较来决定元素见的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也成为非线性时间比较类排序" ID="TaWwe9ADlk" STYLE="fork"/>
          </node>
          <node TEXT="分类" ID="h7kqEYOnIU" STYLE="fork">
            <node TEXT="交换排序" ID="l5AOUbQD9e" STYLE="fork">
              <node TEXT="冒泡排序 Bubble Sort （初级排序）" ID="g8F2NPgshw" STYLE="fork">
                <node TEXT="嵌套循环，每次查看相邻的元素如果逆序，则交换" ID="Af6ay73Mqz" STYLE="fork"/>
                <node TEXT="时间复杂度（平均）：O(n^2)" ID="YurdNO4jv2" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="zrGQDJfAfx" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(n)" ID="MP85ZJoTxK" STYLE="fork"/>
                <node TEXT="空间复杂度：O(1)" ID="fGCszVaGaQ" STYLE="fork"/>
                <node TEXT="稳定性：稳定" ID="JEweaVvzCR" STYLE="fork"/>
              </node>
              <node TEXT="快速排序 Quick Sort （高级排序）" ID="719sHJw6BW" STYLE="fork">
                <node TEXT="数组取标杆pivot，将小元素放pivot左边，大元素放右侧，然后依次堆右边和右边的子数组继续快排；以达到整个序列有序" ID="elho1TIdsZ" STYLE="fork"/>
                <node TEXT="时间复杂度（平均）：O(nlogn)" ID="cM5xsStARB" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="q2z1FRMvva" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(nlogn)" ID="ZfCUycc9Or" STYLE="fork"/>
                <node TEXT="空间复杂度：O(nlogn)" ID="LoKDLEGx4Q" STYLE="fork"/>
                <node TEXT="稳定性：不稳定" ID="vYSk3Wcajq" STYLE="fork"/>
                <node TEXT="先调配出左右子数组，然后对于左右子数组进行排序" ID="fE1h2OBgql" STYLE="fork"/>
                <node TEXT="Java快排代码 （调用方式：quickSort（a, 0, a.length - 1)" ID="WbYh3XOTYo" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="插入排序 Insertion Sort （初级排序）" ID="jGnLFDOCgI" STYLE="fork">
              <node TEXT="从前到后逐步构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入" ID="jAs1qVj7t7" STYLE="fork"/>
              <node TEXT="简单插入排序" ID="OBahGes6DT" STYLE="fork">
                <node TEXT="时间复杂度（平均）：O(n^2)" ID="735p5CuTXA" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="EzhwcDSarQ" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(n)" ID="LYtd4bB7EL" STYLE="fork"/>
                <node TEXT="空间复杂度：O(1)" ID="gJ3knzq4WF" STYLE="fork"/>
                <node TEXT="稳定性：稳定" ID="94zPYtcZB5" STYLE="fork"/>
              </node>
              <node TEXT="希尔排序" ID="6Tv1IcaM1D" STYLE="fork">
                <node TEXT="时间复杂度（平均）：O(n^1.3)" ID="OOzKObxFrY" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="uYMh7wWUqc" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(n)" ID="ju8jVPvLN8" STYLE="fork"/>
                <node TEXT="空间复杂度：O(1)" ID="9Jyhb6Qod5" STYLE="fork"/>
                <node TEXT="稳定性：不稳定" ID="6hsUqYzqYQ" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="选择排序 Selection Sort （初级排序）" ID="kIlwp9PWB7" STYLE="fork">
              <node TEXT="每次找最小值，然后放到待排序数组的起始位置" ID="iXsvviVFcE" STYLE="fork"/>
              <node TEXT="简单选择排序" ID="9PSqPbOg8z" STYLE="fork">
                <node TEXT="时间复杂度（平均）：O(n^2)" ID="goIZXWq91T" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="pLA0mrlcrH" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(n^2)" ID="7U6c5MFmhE" STYLE="fork"/>
                <node TEXT="空间复杂度：O(1)" ID="dKweVDDXbs" STYLE="fork"/>
                <node TEXT="稳定性：不稳定" ID="tPPEHefsR7" STYLE="fork"/>
              </node>
              <node TEXT="堆排序 Heap Sort （高级排序）" ID="Cmv8CuHFzL" STYLE="fork">
                <node TEXT="1. 数组元素依次建立小顶堆" ID="5ykCiUv6Ot" STYLE="fork"/>
                <node TEXT="2. 依次取堆顶元素，并删除" ID="LJLxxZAw4Z" STYLE="fork"/>
                <node TEXT="时间复杂度（平均）：O(n^2)" ID="QD4hFEDUPW" STYLE="fork"/>
                <node TEXT="时间复杂度（最坏）：O(n^2)" ID="JGc37amGdW" STYLE="fork"/>
                <node TEXT="时间复杂度（最好）：O(n)" ID="2z6VPh1Wy4" STYLE="fork"/>
                <node TEXT="空间复杂度：O(1)" ID="Qsjs66tUjz" STYLE="fork"/>
                <node TEXT="稳定性：稳定" ID="ZMVK9BiFSJ" STYLE="fork"/>
                <node TEXT="堆排序Java代码" ID="nPkAfq73tq" STYLE="fork"/>
              </node>
            </node>
            <node TEXT="归并排序 Merge Sort - 分治（高级排序）" ID="ZlCqST2wlq" STYLE="fork">
              <node TEXT="1. 把长度为n的输入序列分成两个长度为n/2的子序列" ID="nmxRmj877S" STYLE="fork"/>
              <node TEXT="2. 对这两个子序列分别采用归并排序" ID="A3GSPmbt1b" STYLE="fork"/>
              <node TEXT="3. 将两个排序好的子序列合并成一个最终的排序序列" ID="dLTmznVWGH" STYLE="fork"/>
              <node TEXT="时间复杂度（平均）：O(nlogn)" ID="ioWpJ1fAMF" STYLE="fork"/>
              <node TEXT="时间复杂度（最坏）：O(nlogn)" ID="5vh5ap9vRa" STYLE="fork"/>
              <node TEXT="时间复杂度（最好）：O(nlogn)" ID="LioClKfDUq" STYLE="fork"/>
              <node TEXT="空间复杂度：O(n)" ID="bCSHQ2EUdp" STYLE="fork"/>
              <node TEXT="稳定性：稳定" ID="OOZM8VG23g" STYLE="fork"/>
              <node TEXT="先排序左右子数组，然后合并有序子数组" ID="pXP6cPXfh9" STYLE="fork"/>
              <node TEXT="归并排序Java代码" ID="1di4ElWddr" STYLE="fork"/>
              <node TEXT="二路归并排序" ID="xeKTvtmpG9" STYLE="fork"/>
              <node TEXT="多路归并排序" ID="dkck6VDPNk" STYLE="fork"/>
            </node>
          </node>
        </node>
        <node TEXT="2.非比较类排序" ID="s0S8VWAvj8" STYLE="fork">
          <node TEXT="定义" ID="RVFEKXgiPf" STYLE="fork">
            <node TEXT="不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序" ID="V2Ec3P9FnM" STYLE="fork"/>
          </node>
          <node TEXT="分类" ID="QyG6FQYgqZ" STYLE="fork">
            <node TEXT="计数排序 Counting Sort" ID="xnTX4SBE7V" STYLE="fork">
              <node TEXT="计数排序要求输入的数据必选是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组" ID="U2WWV3yrDO" STYLE="fork"/>
              <node TEXT="时间复杂度（平均）：O(n+k)" ID="GbYE20cNQO" STYLE="fork"/>
              <node TEXT="时间复杂度（最坏）：O(n+k)" ID="IfpR1QLVlS" STYLE="fork"/>
              <node TEXT="时间复杂度（最好）：O(n+k)" ID="lEvYkNdvcZ" STYLE="fork"/>
              <node TEXT="空间复杂度：O(n+k)" ID="kMz3dMv8dR" STYLE="fork"/>
              <node TEXT="稳定性：稳定" ID="x4gnYT7k42" STYLE="fork"/>
            </node>
            <node TEXT="桶排序 Bucket Sort" ID="Z6wtGCxwqr" STYLE="fork">
              <node TEXT="工作原理" ID="fsX0dhdgxB" STYLE="fork">
                <node TEXT="假设输入数据服从均匀分布，将数据分到优先数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）" ID="MKYcQS4wyc" STYLE="fork"/>
              </node>
              <node TEXT="时间复杂度（平均）：O(n+k)" ID="4APn5fvPFC" STYLE="fork"/>
              <node TEXT="时间复杂度（最坏）：O(n^2)" ID="nMGpG6j7VK" STYLE="fork"/>
              <node TEXT="时间复杂度（最好）：O(n)" ID="oMSxrHJiQK" STYLE="fork"/>
              <node TEXT="空间复杂度：O(n+k)" ID="EkN8xCm4v8" STYLE="fork"/>
              <node TEXT="稳定性：稳定" ID="mwjWpVAX4S" STYLE="fork"/>
            </node>
            <node TEXT="基数排序 Radix Sort" ID="l4G4VLGchY" STYLE="fork">
              <node TEXT="基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是由优先级顺序的，先按低优先级排序，再按高优先级排序" ID="c8mQ8sg5SE" STYLE="fork"/>
              <node TEXT="时间复杂度（平均）：O(n*k)" ID="vdOXFz0kss" STYLE="fork"/>
              <node TEXT="时间复杂度（最坏）：O(n*k)" ID="mvr339J1Bz" STYLE="fork"/>
              <node TEXT="时间复杂度（最好）：O(n*k)" ID="QGwFSdbuDg" STYLE="fork"/>
              <node TEXT="空间复杂度：O(n+k)" ID="OcG4lYCK0O" STYLE="fork"/>
              <node TEXT="稳定性：稳定" ID="ZqxYAY4iZ7" STYLE="fork"/>
            </node>
          </node>
        </node>
      </node>
      <node TEXT="数学Math" ID="Jyxj0Qn7XJ" STYLE="fork"/>
      <node TEXT="集合 Geometry" ID="LhQZK2C3Op" STYLE="fork"/>
    </node>
    <node TEXT="时间复杂度" ID="xc8Cf7dFxi" STYLE="bubble" POSITION="default">
      <node TEXT="O(1)：常数复杂度 Constant Complexity" ID="QLr65xvlpt" STYLE="fork"/>
      <node TEXT="O(log n)：对数复杂度 Logarithmic Complexity" ID="BM5iIfipKi" STYLE="fork"/>
      <node TEXT="O(n)：线性时间复杂度 Linear Complexity" ID="DS5iFdvAft" STYLE="fork"/>
      <node TEXT="O(n^2)：平方 N square Complexity" ID="lFFHfhXLn1" STYLE="fork"/>
      <node TEXT="O(n^3)：立方 N cubic Complexity" ID="NfDXhXfJoA" STYLE="fork"/>
      <node TEXT="O(2^n)：指数 Exponential Growth" ID="HQbQLz9EPJ" STYLE="fork"/>
      <node TEXT="O(n!)：阶乘 Factorial" ID="N9o9D8YkCS" STYLE="fork"/>
    </node>
    <node TEXT="空间复杂度" ID="5NDijjM475" STYLE="bubble" POSITION="default">
      <node TEXT="判断依据" ID="hNumJxMFLQ" STYLE="fork">
        <node TEXT="数组的长度" ID="Upjs0lZo28" STYLE="fork"/>
        <node TEXT="递归的深度" ID="w4O9IkPISh" STYLE="fork"/>
      </node>
    </node>
  </node>
</map>